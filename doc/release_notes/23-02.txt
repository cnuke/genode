

              ===============================================
              Release notes for the Genode OS Framework 23.02
              ===============================================

                               Genode Labs



;intro
; @nfeske

; road map
; * Mobile version of Sculpt OS (PinePhone)
;   * Ready-to-use system image for first field test
;   * Quick switch between different system scenarios as presets
;   * On-target system update
;   * Boot optimization
; * Goa support for porting 3rd-party libraries to Genode
; * Improved I/O performance (Intel GPU buffer management, VFS I/O batching,
;   TCP throughput)
; * Custom IP block for DMA protection on Xilinx Zynq
; * PC suspend/resume mechanism for the base-hw kernel
; * Optimized base-hw multimedia support (kernel scheduling, latency)
; * Completed driver support for MNT Reform 2 laptop (i.e., Wifi)
; * Interactive graphical VMs on ARM


First system image of mobile Sculpt OS (PinePhone)
##################################################

Just in time for our
[https://fosdem.org/2023/schedule/event/genode_on_the_pinephone/ - public presentation]
of Genode on the PinePhone at FOSDEM in the beginning of February,
we published a first ready-to-use system image:

:First system image of mobile Sculpt OS:

  [https://genodians.org/nfeske/2023-02-01-mobile-sculpt]

It features a
[https://genodians.org/nfeske/2023-01-05-mobile-user-interface - custom user interface],
voice calls and mobile-data connectivity, on-target software installation and
system update, device controls (battery, brightness, volume, mic, reset,
shutdown), and a variety of installable software.
Among the installable applications, there is the Chromium-based Morph web
browser, an OpenGL demo using the GPU, tests for the camera and microphone, as
well as a light-weight Unix-like system shell.

The underpinnings of the Genode system image for the PinePhone are nearly
identical to Sculpt OS on the PC. However, besides the new user interface
specifically designed for the touch screen of the phone, two noteworthy
differences set it apart from the regular version of Sculpt OS.

First, the phone variant allows the user to rapidly switch between different
runtime configurations, called presets. This way, the limited resources of the
phone can be accounted and fully leveraged for each preset individually, while
making the system extremely versatile. The loading of a preset can be imagined
as the boot into a separate operating system. But it takes only a fraction of
a second. The structure of the running system is made fully transparent to the
user by the component graph known from Sculpt OS.

Second, the system is equipped with an on-target system update mechanism that
allows the user to install new versions of the system image when they become
available. System updates are secured by cryptographic signatures. The
mechanism does not only allow for updating the system but also for the
rollback to any previously downloaded version. This way, the user can try
out a new version while being able to fall back to the previous one in the
case of a regression. This reinforces the end user's ultimate control.


Interactive graphical VMs on ARM
################################

The virtual-machine monitor (VMM) using hardware-assisted virtualization on ARM
started as a case study eight years ago for Samsung's Exynos 5250 SoC.
Originally, it supported virtualization of CPU, timer, interrupt-controller, and
an UART-device only. Since then it received several extensions. Support for
64-bit ARMv8 systems, VirtIO devices for network, console, and block access.
With release 22.11 the VMM was made configurable to not necessarily provide
each-and-every I/O access, and to define RAM consumption and CPU count.

With this release, we further enhance the VMM for ARM devices
to provide all the means necessary to become a useful virtualization
solution for interactive scenarios.

Two additional VirtIO device models are available now: a GPU model and one for input.
Both models are mapped to Genode's GUI service under the hood. One can extend
the configuration of the VMM accordingly:

! <config ...>
!  <virtio_device name="fb0"    type="gpu"/>
!  <virtio_device name="event0" type="input"/>
!  ...
! </config>

By now, it is possible to declare only one GPU and one input device. Both get
mapped to the very same GUI service, according to the service routing of the
VMM.

Caution: the GPU and input model are still in an experimental state, and there
are known corner cases, e.g., when the graphical window size of the VMM gets
changed dynamically.

Formerly, the VMM always expected an initial RAM filesystem to be provided as
ROM dataspace, which got loaded together with the Linux kernel into the
VM's memory. Now, it is possible to omit the "initrd_rom" configuration option.
If left out, no initrd is provided to the Linux guest.


Custom IP block for DMA protection on Xilinx Zynq
#################################################

; @jschlatow

commit 6fb1e1e6bae488f2fa19d76a317c80c58f3d6205
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Fri Dec 16 14:45:37 2022 +0100

    tool: deal with xsa containing multiple hwh files

commit 7b0b0811546975b33eba7cead455ba6f8fb83f90
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Fri Nov 11 16:42:00 2022 +0100

    add xilinx axidma driver library
    
    The library bases on the xilinx_embeddedsw port.

commit c3933e12f3705be1e4ebd0e80dbb4317f3b97a51
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Tue Jan 17 18:42:01 2023 +0100

    dma_loopback test
    
    This adds a run script for testing the DMA throughput with the dma_loopback
    bitstream. The bitstream comprises two DMA IP cores, one is connected
    via AXI_HP and the other via AXI_ACP. The ACP allows using CACHED memory
    as DMA buffers.

commit 1764372c56579e99de78ffd21fbdd823ef476020
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Thu Jan 19 16:45:21 2023 +0100

    zynq_uboot_sdcard: move uImage to /boot/uImage
    
    This commit changes the default uboot env to expect bitstream files and
    uEnv.txt inside the /boot/ directory.
    
    Issue genodelabs/genode#4730

commit f83377e63e6e130b3588fa313fd8e7cfcceba05d
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Wed Feb 22 11:06:19 2023 +0100

    platform_drv: add support for control devices

commit 4cef6d42c7f6a9c8c87ffc28768e97677dafe0c6
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Mon Jan 23 16:28:56 2023 +0100

    platform_drv: remove hard-coded slcr device
    
    With the introduction of control devices in the generic platform driver,
    we are able to use information from the devices ROM to create control
    devices such as the slcr device.

commit 43e2e85cc63b798bc841c63fed3178975044b3aa
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Wed Dec 21 20:58:52 2022 +0100

    platform_drv: add dma_guard control device

commit 719157a1a6fc9426091d8f9c22ca2d151e797407
Author: Johannes Schlatow <johannes.schlatow@genode-labs.com>
Date:   Wed Feb 22 14:28:18 2023 +0100

    dma_guard test


Base framework and OS-level infrastructure
##########################################

VFS optimization and simplification
===================================

For regular applications executed on Genode, input and output involves the
virtual file system (VFS). In contrast to traditional monolithic operating
systems (which host the VFS in the kernel) or traditional microkernel-based
operating systems (which host the VFS in a dedicated server component),
Genode's VFS has the form of a library, giving each component an individual
virtual file system. The feature set of the VFS library is not fixed
but extensible by so-called VFS plugins that come in the form of optional
shared libraries. These plugins can implement new file-system types, but also
expose other I/O facilities as pseudo files. For example, TCP/IP stacks like
lwIP and lxIP (IP stack ported from Linux) have the form of VFS plugins.
The extensibility of the VFS gives us extreme flexibility without compromising
Genode's simplicity.

On the other hand, the pervasiveness of the VFS - being embedded in
Genode's C runtime - puts it on the performance-critical path whenever
application I/O is involved.
The ever growing sophistication of application workloads like running a
Chromium-based web browser on the PinePhone puts merciless pressure on the
VFS, which motivated the following I/O-throughput optimizations.

Even though the VFS and various VFS plugins work asynchronously, the
batching of I/O operation is not consistently effective across different
kernels. It particularly depends on the kernel's scheduling decision upon the
delivery of asynchronous notifications. Kernels that eagerly switch to the
signal receiver may thereby prevent the batching of consecutive write
operations. We could observe variances of more than an order of magnitude of
TCP throughput, depending on the used kernel. In the worst case, when using
a kernel that eagerly schedules the recipient of each asynchronous notification,
the application performance is largely dominated by context-switching costs.

Based on these observations, we concluded that the influence of the kernel's
scheduler should better be mitigated by scheduling asynchronous notifications
less eagerly at the application level. By waking up a remote peer not before
the application stalls for I/O, all scheduled operations would appear at the
remote side as one batch.

The implementation of this idea required a slight redesign of the VFS,
replacing the former implicit wakeup of remote peers by explicit wakeup
signalling. The wakeup signalling is triggered not before the VFS user settles
down. E.g., for libc-based applications, this is the case if the libc goes
idle, waiting for external I/O.
In the case of a busy writer to a non-blocking file descriptor or socket
(e.g., lighttpd), the remote peers are woken up once a write operation
yields an out-count of 0.
The deferring of wakeup signals is accommodated by the new 'Remote_io'
mechanism (_vfs/remote_io.h_) that is designated to be used by all VFS
plugins that interact with asynchronous Genode services for I/O.

Combined with additional adjustments of I/O buffer sizes - like the request
queue of the file-system session, the TCP send buffer of the lwIP stack, or the
packet buffer of the NIC session - the VFS optimization almost eliminated
the variance of the I/O throughput among the different kernels and generally
improved the performance. On kernels that suffered most from the eager
context switching, netperf
[https://github.com/genodelabs/genode/issues/4697#issuecomment-1342542399 - shows a 10x]
improvement. But even on kernels with more balanced scheduling, the effect is
impressive.

While we were at it, and since this structural change affected all VFS plugins
and users anyway, we took the opportunity to simplify and modernize other
aspects of the VFS-related code as well.

In particular, the new interface 'Vfs::Env::User' replaces the former
'Vfs::Io_response_handler'. In contrast to the 'Io_response_handler', which
had to be called on a 'Vfs_handle', the new interface does not require any
specific handle. It is merely meant to prompt the VFS user (like the libc) to
re-attempt stalled I/O operations but it does not provide any immediate hint,
about which of the handles have become ready for reading/writing. This change
led to welcome simplifications of asynchronously working VFS plugins.

Furthermore, we removed the 'file_size' type from read/write interfaces.
The former C-style pair of (pointer, size) arguments to those operations have
been replaced by 'Byte_range_ptr' and 'Const_byte_range_ptr' argument types,
which make the code safer and easier to follow. Also the VFS utilities offered
by _os/vfs.h_ benefit from this safety improvement.


GPU performance optimizations
=============================

; @ssumpf, @cnuke

commit 77ff380d937eeb9257cf91f81fe15b148258af3e
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Fri Dec 16 17:51:55 2022 +0100

    gpu_session: VRAM interface
    
    Change the abstraction from buffers to video RAM (VRAM). The notion of
    buffers can be provided at the client side (e.g., Mesa) and multiple
    buffers can be there be associated to one VRAM area, thus saving
    resources (meta data overhead) when allocating many buffers. A VRAM area
    can also be mapped to one single buffer as before for clients or drivers
    that do not take advantage of this feature.
    
    issue #4713

commit 15300e53da6cb25e73d53aeb3e726725b3161667
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Fri Dec 16 20:41:27 2022 +0100

    libdrm/iris: remove unsused functions
    
    * 'map_buffer', GTT mappings are currently not used by Iris
    * 'set_tiling', tiling is currently not used by Iris because there are
      no GTT mappings
    
    issue #4713

commit 1a9dd1d46c5b96ac4d6548ccc2d8d80e185b767d
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Sun Dec 18 16:49:28 2022 +0100

    ibdrm/iris: add VRAM support
    
    Allocate 16MB or larger chunks and implement buffer abstraction for Iris
    which possible share VRAM.
    
    issue #4713

commit 4bbc04ab6cafac154499ea1a8afa1400668455c8
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Sun Dec 18 18:19:08 2022 +0100

    gpu/intel: add VRAM support
    
    Remove buffer abstraction and replace it by VRAM objects.
    
    issue #4713

commit 098a0d5a8834082ff23630adcbef1f02ebc9d4bf
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Thu Feb 9 15:13:07 2023 +0100

    fixup "gpu/intel: add VRAM support"

commit 51c2c9153e73902d0a22a8155fec66a6e7b7b295
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Tue Jan 3 10:26:58 2023 +0100

    libdrm/lima+etnaviv: adjust to VRAM GPU session interface
    
    Keep buffer abstraction by mapping one buffer to one VRAM object.
    
    issue #4713

commit 9d48c28f9bfacfe6a89d28073470b84c3eed7ddf
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Fri Jan 20 18:56:16 2023 +0100

    gpu_session: add notes to interface
    
    Describe differences for Intel and Lima (Mali) based GPUs.
    
    issue #4713

commit 99370f2f40064df96096ce35cae7b4bc95b3c815
Author: Josef Söntgen <jws@sysret.de>
Date:   Tue Dec 20 16:10:16 2022 +0000

    libdrm/lima: refactor session and context handling
    
    Merge 'Gpu_session' and 'Gpu_context' and create the main session
    as context.
    
    Issue #4760.

commit 3a217e2460577f5fcc552b24a656e2f2cad4323b
Author: Josef Söntgen <jws@sysret.de>
Date:   Tue Dec 20 16:16:14 2022 +0000

    libdrm/lima: rename Syncobj_space
    
    Align the naming with the 'Gpu_context_space'.
    
    Issue #4760.

commit 98d6111a8e4ecb8ba652ce22d335fd198fbd8d3d
Author: Josef Söntgen <jws@sysret.de>
Date:   Tue Dec 20 17:35:47 2022 +0000

    libdrm/lima: handle unknown buffer ids gracefully
    
    Issue #4760.

commit e562c5e7459e98f965ee6ddecb7234806179b3ca
Author: Josef Söntgen <jws@sysret.de>
Date:   Tue Dec 20 17:34:01 2022 +0000

    libdrm/lima: check buffer id in WAIT
    
    Issue #4760.

commit 1ff6d1a56335daebfcc5af5dc89f2c36c8a97196
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Tue Jan 10 18:16:00 2023 +0100

    libdrm/lima: introduce disjunct contexts
    
    Prior to this change the libdrm Lima implementation supported the
    creation of multiple contexts where each context, however, was
    treated as the same client like it was done in the Lima driver
    itself.
    
    With this commit each context becomes its own client while the
    main context always performs all buffer object related allocation
    and the other context import each needed BO before submitting.
    
    Fixes #4760.

commit 8584fbc37350c90a27a03cafc26b9f384ed1dde1
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Tue Jan 3 10:47:06 2023 +0100

    gpu/lima: adjust to VRAM GPU session interface
    
    Map one buffer to one VRAM object.
    
    genodelabs/genode#4713

commit db610dab3234e5ddafb5929b225ca73414dc4c5d
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Fri Jan 20 18:40:07 2023 +0100

    gpu_session: rename Gpu::Virtual_address:va
    
    rename 'va' into 'value' to stay consistent with other types.
    
    issue #4713

commit 41077afa73706edffe7250be27819ba310ef8ab3
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Fri Feb 10 13:40:01 2023 +0100

    gpu/lima: properly implement context handling
    
    The prior implementation already supported creating multiple contexts
    but from the point of view of Linux they still where the same client
    and furthermore there was only on Lx::Task handling the communication.
    This prohibited the support of concurrently operating disjunct clients
    as well as complicated the client-side processing in multi-threaded
    components.
    
    This commit changes the implementation by modelling each Gpu::Session
    as its own client whose requests are processed by its own Lx::Task.
    Like with the Intel GPU multiplexer Vram objects are exported and
    imported accordingly.
    
    Fixes #15.


More flexible ACPI-event handling
=================================

The _acpica_ component uses the Intel ACPICA library to parse and interpret
ACPI tables and AML code. One designated feature is the monitoring of
several ACPI event sources incl. optionally reporting of information about
state changes. The supported event sources are like follows.

* Lid, which can be open or closed
* Smart battery (SB), information about battery parameters (e.g., capacity)
  and charging resp. discharging status
* ACPI fixed events, e.g., power buttons
* AC adapters, which reflect power cable plug/unplug
* Embedded controller (EC), events like Fn-* keys, Lid, AC, SB changes
* Vendor-specific hardware events, e.g., Fujitsu FUJ02E3 key events

Acpica optionally reports information about state changes and these reports
can be monitored by other components as ROMs. The following configuration
illustrates the feature.

!<start name="report_rom">
!  <resource name="RAM" quantum="2M"/>
!  <provides> <service name="ROM" /> <service name="Report" /> </provides>
!  <config>
!    <policy label="acpi_event -> acpi_lid"     report="acpica -> acpi_lid"/>
!    <policy label="acpi_event -> acpi_battery" report="acpica -> acpi_battery"/>
!    <policy label="acpi_event -> acpi_fixed"   report="acpica -> acpi_fixed"/>
!    <policy label="acpi_event -> acpi_ac"      report="acpica -> acpi_ac"/>
!    <policy label="acpi_event -> acpi_ec"      report="acpica -> acpi_ec"/>
!    <policy label="acpi_event -> acpi_hid"     report="acpica -> acpi_hid"/>
!  </config>
!</start>
!
!<start name="acpica">
!  <resource name="RAM" quantum="8M"/>
!  <config report="yes"/>
!  <route>
!    <service name="Report"> <child name="acpi_state"/> </service>
!    ...
!  </route>
!</start>

One such ACPI monitor component is _acpi_event_ that maps ACPI events to key
events of a requested Event session based on configuration. So, ACPI state
changes can be processed like ordinary key press-release events via, for
example, the _event_filter_. The following configuration illustrates how to
map the ACPI event types to key events.

!<start name="acpi_event">
!  <resource name="RAM" quantum="1M"/>
!  <config>
!    <map acpi="lid"   value="CLOSED"    to_key="KEY_SLEEP"/>
!    <map acpi="fixed" value="0"         to_key="KEY_POWER"/>
!    <map acpi="ac"    value="ONLINE"    to_key="KEY_WAKEUP"/>
!    <map acpi="ec"    value="20"        to_key="KEY_BRIGHTNESSUP"/>
!    <map acpi="ec"    value="21"        to_key="KEY_BRIGHTNESSDOWN"/>
!    <map acpi="hid"   value="0x4000000" to_key="KEY_FN_F4"/>
!  </config>
!  <route>
!    <service name="ROM" label="acpi_lid">     <child name="acpi_state"/> </service>
!    <service name="ROM" label="acpi_battery"> <child name="acpi_state"/> </service>
!    <service name="ROM" label="acpi_fixed">   <child name="acpi_state"/> </service>
!    <service name="ROM" label="acpi_ac">      <child name="acpi_state"/> </service>
!    <service name="ROM" label="acpi_ec">      <child name="acpi_state"/> </service>
!    <service name="ROM" label="acpi_hid">     <child name="acpi_state"/> </service>
!    <service name="Event"> <child name="event_filter" label="acpi"/> </service>
!    ...
!  </route>
!</start>

In this release, we replaced the limited list of supported key names by a
general mechanism, which supports the use of all key names declared in
_repos/os/include/input/keycodes.h_.


Base API changes
================

As part of our continuous motive to streamline and simplify the framework's
base API as much as possible, the current release removes
the interfaces _base/blocking.h_, _base/debug.h_, and _base/lock_guard.h_
as those headers contained parts of the API that have become obsolete by now.
As a further minor change, the 'abs' function of _util/misc_math.h_ got removed.

The string utilities _util/string.h_ received the new 'Const_byte_range_ptr'
type complementing the existing 'Byte_range_ptr'. Both types are designated
for passing arguments that refers to a byte buffer, e.g., the source buffer of
a write operation.


On-target system-update and rollback mechanism
##############################################

For the mobile version of Sculpt OS as covered in
Section [First system image of mobile Sculpt OS (PinePhone)],
we envisioned easy-to-use system updates that would enable us to quickly
iterate based on the feedback of early field testers.

This topic confronted us with a variety of concerns. Just to name a few,
conventions for booting that would not require changes in the future,
equipping (system) images with self-reflecting version information,
tools for generating and publishing digitally signing images,
on-target discovery of new image versions,
secure downloading and cryptographic checking of new images,
directing the machine's boot loader to use the new version, and
possibly reverting to an earlier version.

Fortunately, most of these concerns have a lot in common with the problems
we had to address for Genode's
[https://genode.org/documentation/release-notes/18.02#On-target_package_installation_and_deployment - package management].
For example, the off-target and on-target tooling for digital signatures, or
the notion a depot and software providers (depot users) is established
and time-tested by now.


Self-reflecting version information
-----------------------------------

To allow a running Sculpt system to know its own version, the sculpt.run
script generates an artificial boot module named "build_info", which can
be evaluated at runtime by the sculpt-manager component.

! <build_info genode_version="22.11-260-g89be3404c0d"
!             date="2023-01-19" depot_user="nfeske" board="pinephone">


Formalism for generating images and image metadata
--------------------------------------------------

To enable Sculpt system to easily detect new versions, system images must be
accompanied by metadata discoverable at a known location. This information
is provided by a so-called image-index file located at
_depot/<user>/image/index_. The image index of a depot user lists the
available images in XML form, e.g.,

! <index>
!   <image os="sculpt" board="pinephone" version="2023-01-19">
!      <info text="initial version"/>
!   </image>
!   ...
! </index>

The 'os', 'board', and 'version' attributes can be used to infer the
file name of the corresponding image file. The '<info>' nodes contains
a summary of changes as information for the end user.

The new _gems/run/sculpt_image.run_ Sculpt provides assistance with
generating appropriately named images, placing them into the depot,
and presenting a template for the manually curated image index.


Signing and publishing
----------------------

For signing and publishing system images and image indices, we extended
the existing _tool/depot/publish_ tool. To publish a new version of an
image index:

! ./tool/depot/publish <depot-user>/image/index

Each system image comes in two forms, a bootable disk image and an archive of
the boot directory. The bootable disk image can be used to install a new
system from scratch by copying the image directly to a block device. It
contains raw block data. The archive of the boot directory contains the
content needed for an on-target system update to this version. Within the
depot, this archive a directory - named after the image - that contains the
designated content of the boot directory on target. Depending on the board, it
may contain only a single file loaded by the boot loader (e.g., uImage), or
several boot modules, or even the boot-loader configuration. The following
command publishes both forms:

! ./tool/depot/publish <depot-user>/image/<image-name>

This results in the following - accompanied by their respective .sig
files - in the public directory:

! <depot-user>/image/<image-name>.img.xz  (disk image)
! <depot-user>/image/<image-name>.tar.xz  (boot archive)
! <depot-user>/image/<image-name>.zip     (disk image)

The .zip file contains the .img file. It is provided for users who
download the image on a system with no support for .xz.


On-target image discovery, download, and verification
-----------------------------------------------------

To enable a running Sculpt system to fetch image index files and images, the
existing depot-download component accepts the following two new download
types:

! <image_index path="<user>/image/index"/>
! <image       path="<user>/image/<name>"/>

Internally, the depot-download subsystem employs the depot-query
component to determine the missing depot content. This component
accepts the following two new queries:

! <images      user="..."/>
! <image_index user="..."/>

If present in the query, depot_query generates reports labeled as
"images" and "image_index" respectively. These reports are picked up by
the depot-download component to track the completion of each job.
The reported information is also used by the system updater to get hold of
the images that are ready to install.


On-target image installation and rollback
-----------------------------------------

Once downloaded into the local depot of a Sculpt system, the content
of boot directory for a given image version is readily available, e.g.,

! depot/nfeske/image/sculpt-pinephone-2023-02-02/uImage

The installation comes down to copying this content to the _/boot/_ directory.
On the next reboot, the new image is executed.

When subsequently downloading new image versions, the old versions stay
available in the depot is sibling directories. This allows for an easy
rollback by copying the boot content of an old version to the _/boot/_
directory.


Device drivers
##############

NXP i.MX Ethernet & USB
=======================

The Ethernet driver for i.MX53, i.MX6, and i.MX7 got updated to use a more
recent Linux kernel version (5.11). These drivers got aligned with the source
code base originally ported for the i.MX8 SoC.

Using the recent approach to port Linux device drivers, trying to preserve the
original semantic, it is necessary to provide the correct related clock rates to
the driver. Therefore, specific platform drivers for i.MX6 and i.MX7 were
created that enable the network related clocks and export their rate values. The
i.MX53 related platform driver got extended to support these clocks.

The USB host-controller driver for the i.MX 8MQ EVK is now able to drive the
USB-C connector of this board too.

NVMe
====

; @cnuke

commit 7e5af1b7a5a8565f8216a97221bc4e36f17369bd
Author: Josef Söntgen <jws@sysret.de>
Date:   Mon Jan 2 20:39:17 2023 +0000

    nvme_drv: move PRP list helper construction
    
    Since the 'Platform::Device' constructor will defer the creation until
    the content of the devices ROM is valid performing the PRP list helper
    creation afterwards should be done with valid IOMMU information.
    
    Issue #4715.

commit 63ff0ee869d0369ef5bf30aa658fb82610ecea6f
Author: Josef Söntgen <jws@sysret.de>
Date:   Thu Dec 22 13:59:59 2022 +0000

    nvme_drv: allow for accessing admin cmd results
    
    Up to now it was only checked if an issued admin command was processed
    in a timely fashion. Otherwise it has been treated as failed.
    However, the completion-queue entry was not examined and the caller was
    not able to access the entry itself. Depending on the command, checking
    the completion-queue entry might be necessary, e.g. GET/SET_FEATURE.
    
    Issue #4715.

commit 827aa9586e5a07229f37ef0918f2159b54f4787a
Author: Josef Söntgen <jws@sysret.de>
Date:   Sun Nov 13 20:11:16 2022 +0000

    nvme_drv: provide get/set feature command
    
    These admin commands are used to configure features of the NVMe device.
    
    Issue #4715.


Realtek Wifi
============

; @cnuke

commit d27bd158093aa9d069b4a19aaac53cfc843a9414
Author: Josef Söntgen <jws@sysret.de>
Date:   Wed Jan 4 12:03:27 2023 +0000

    wifi/pc: add rtlwifi driver
    
    Due to lacking hardware access the driver was test with one RTL8188EE
    based device, namely [10ec:8179] (rev 01), only. As the access to the
    PCI config space is restricted the driver loads the non power-saving
    FW and the driver port is therefor only tested with that. The
    accesses are documented should we choose to support them one way or
    another later on.
    
    The 'wifi.run' run script as well as Sculpt served as testing ground
    where the driver worked fine so far.
    
    Fixes #4714.

commit d27bd158093aa9d069b4a19aaac53cfc843a9414
Author: Josef Söntgen <jws@sysret.de>
Date:   Wed Jan 4 12:03:27 2023 +0000

    wifi/pc: add rtlwifi driver
    
    Due to lacking hardware access the driver was test with one RTL8188EE
    based device, namely [10ec:8179] (rev 01), only. As the access to the
    PCI config space is restricted the driver loads the non power-saving
    FW and the driver port is therefor only tested with that. The
    accesses are documented should we choose to support them one way or
    another later on.
    
    The 'wifi.run' run script as well as Sculpt served as testing ground
    where the driver worked fine so far.
    
    Fixes #4714.


Platforms
#########

Base-HW microkernel
===================

Cache maintenance optimization
------------------------------

On ARM systems, the memory view on instructions and data of the CPU, as well as
in between CPU and other devices is not necessarily consistent. When dealing
with DMA transfers of devices, developers of related drivers need to ensure that
corresponding cache lines are cleaned before a DMA transfer gets acknowledged.
When dealing with just-in-time compilation, where instructions a generated on
demand, the data and instruction caches have to be aligned too.

Until now, the base-API functions for such cache maintenance were
mapped to kernel system calls specific to base-hw. Only the kernel was allowed
to execute cache maintenance related instructions. On ARMv8 however, it is
possible to allow unprivileged components to execute most of these instructions.

With this release, we have implemented the cache maintenance functions outside
the kernel on ARMv8 if possible. Thereby, several device drivers with a lot of
DMA transactions, e.g. the GPU driver, benefit from this optimization
enormously. The Javascript engine used in the Morph and Falkon browser can be
executed faster too.

In the previous release, we started to support the low-level
[https://genode.org/documentation/release-notes/22.11#Low-level_mechanism_for_suspend_resume_on_PC_platforms - ACPI suspend and resume]
mechanism with Genode for the NOVA kernel. With the current release, we
added the required low-level support to Genode's base-hw kernel for x86 64bit
platforms. Similar to the base-nova version, on base-hw the 'Pd::managing_system'
RPC function of Genode's core roottask is used to transfer the required ACPI
values representing the S3 sleep state to the kernel. The kernel then takes
care to halt all CPUs and flush its state to memory, before finally suspending
the PC using the ACPI mechanism. On resume, the kernel re-initializes
necessary hardware used by the kernel, e.g., all CPUs, interrupt controller,
timer device, and serial device. One can test drive the new feature using
the run/acpi_suspend scenario introduced by the former release.


Scheduling improvements for interactive workloads
-------------------------------------------------

; @m-stein

commit fc690f1c47ef316f46e0919b10715648c124a080
Author: Stefan Kalkowski <stefan.kalkowski@genode-labs.com>
Date:   Fri Dec 16 11:53:27 2022 +0100

    hw: re-work the ipc node's internal state machine
    
    * Split the internal state into incoming and outgoing message relations
    * Avoid fragmenting of one state like formerly '_state' and '_help'
    * Remove pointer to caller, use incoming FIFO instead
    
    This commit fixes at least two bugs that were triggered by tests that
    destroy threads in many different states, like run/bomb:
    
    * The '_help' data member was not reset reliable in each situation where a
      helping relationship came to an end. However, when we fixed this bug alone
      in the old state model, the issues remained. The new state model fixes
      this bug as well.
    
    * A thread sometimes referenced an already dead thread as receiver. This caused
      the kernel IPC code to access the vtable of an object that didn't exist any
      longer. Note that the two threads were not in direct IPC relationship while
      the receiver was destroyed, so, there must have been an intermediate node
      between them. Due to the complexity of this problem, we eventually gave up
      pin-pointing the exact reason in the kernel IPC code. The issue disappeared
      with the new state model.
    
    Fix genodelabs/genode#4704

commit 0467b4aaf33be16f298a43481432731021bd97e9
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Wed Dec 21 19:33:23 2022 +0100

    base-hw scheduler: optimize quota depletion events
    
    This is an optimization for the case that a prioritized scheduling context
    needs slightly more time during a round than granted via quota. If this is the
    case, we move the scheduling context to the front of the unprioritized schedule
    once its quota gets depleted and thereby at least ensure that it does not have
    to wait for all unprioritized scheduling contexts as well before being
    scheduled again.
    
    Note that this introduces the possibility of undeserved starvation of
    unprioritized scheduling contexts to the scheduling scheme. If there are
    enough prioritized contexts that deplete their quota during a round,
    they may cover up also the rest of the round with their unprioritized time
    slices. If this happens every round, contexts without a priority/quota may
    never get a turn. In the previous scheduling scheme, this could not occur as
    the unprioritized schedule was completely independent from prioritized
    schedules and rounds.
    
    Ref #4151
    Ref #4710


NOVA microhypervisor
====================

ACPI suspend & resume
---------------------

As extension to the principal [https://genode.org/documentation/release-notes/22.11#Low-level_mechanism_for_suspend_resume_on_PC_platforms - ACPI suspend and resume]
support introduced with the Genode 22.10 release, the NOVA kernel
now supports also the re-enabling of the IOMMU after ACPI resume. The IOMMU is
a hardware feature supported since [https://genode.org/documentation/release-notes/13.02#DMA_protection_via_IOMMU - 13.02 release]
and extended in [https://genode.org/documentation/release-notes/20.11#NOVA_microhypervisor - 20.11 release], which
sandboxed device hardware and (malicious/faulty) drivers to avoid arbitrary DMA transactions.

Intel P/E cores
---------------

With the start of the [https://en.wikipedia.org/wiki/Intel_Core#12th_generation - 12th Intel CPU generation],
Intel introduced CPUs with heterogeneous cores, similar to
[https://en.wikipedia.org/wiki/ARM_big.LITTLE - ARM's big/LITTLE] concept.
The new CPUs have a number of so called P-cores (performance) and E-cores
(efficient), which differ in their performance and power characteristics.
The CPU cores are
([https://en.wikipedia.org/wiki/Alder_Lake#CPUID_incoherence - mostly/should be]) instruction
compatible and are reported identical via's x86 CPUID instruction nowadays.
However, an operating system such as Genode must be able to differentiate the
cores in order to take informed decisions about placement or scheduling
of Genode components.

With the current release, we added support to the NOVA kernel to propagate the
information about P/E cores to Genode's 'core' roottask. In Genode's core,
this information is used to group the CPU cores into Genode's
[https://genode.org/documentation/release-notes/13.08#Management_of_CPU_affinities - affinity space].
With
[https://genode.org/documentation/release-notes/20.05#NOVA_microhypervisor - release 20.05],
we introduced the grouping of hyperthreads on the y-axis, which we kept if the
P-cores have the feature enabled. Following the P-cores and hyperthreads,
all remaining E-cores are placed in the affinity space.

The following examples showcases the grouping in the affinity-space on x/y axis:

Core i7 1270P - 4 P-cores (hyperthreading enabled) and 8 E-cores:

! x-axis      1  2  3  4  5  6  7  8
! ----------------------------------
! y-axis  1 | P\ P\ P\ P\ E  E  E  E
!         2 | P/ P/ P/ P/ E  E  E  E
!
! hyperthreads \ / of same core

Core i7 1280P - 6 P-cores (hyperthreading enabled) and 8 E-cores:

! x-axis      1  2  3  4  5  6  7  8  9  10
! -----------------------------------------
! y-axis  1 | P\ P\ P\ P\ P\ P\ E  E  E  E
!         2 | P/ P/ P/ P/ P/ P/ E  E  E  E
!
! hyperthreads \ / of same core

The information about the P/E cores are visible in the kernel and Genode's
log output and are reported in the 'platform_info' ROM, e.g.

! kernel:
!
!￼[ 0] CORE:00:00:0 6:9a:3:7 [415] P 12th Gen Intel(R) Core(TM) i7-1270P
! ...
!￼[15] CORE:00:17:0 6:9a:3:7 [415] E 12th Gen Intel(R) Core(TM) i7-1270P
! ...

! Genode's core:
!
! mapping: affinity space -> kernel cpu id - package:core:thread
! ￼ remap (0x0) ->  0 - 0: 0:0 P boot cpu
! ￼ remap (0x1) ->  1 - 0: 0:1 P
! ￼ remap (1x0) ->  2 - 0: 4:0 P
! ￼ remap (1x1) ->  3 - 0: 4:1 P
! ￼ remap (2x0) ->  4 - 0: 8:0 P
! ￼ remap (2x1) ->  5 - 0: 8:1 P
! ￼ remap (3x0) ->  6 - 0:12:0 P
! ￼ remap (3x1) ->  7 - 0:12:1 P
! ￼ remap (4x0) ->  8 - 0:16:0 E
! ￼ remap (4x1) ->  9 - 0:17:0 E
! ￼ remap (5x0) -> 10 - 0:18:0 E
! ￼ remap (5x1) -> 11 - 0:19:0 E
! ￼ remap (6x0) -> 12 - 0:20:0 E
! ￼ remap (6x1) -> 13 - 0:21:0 E
! ￼ remap (7x0) -> 14 - 0:22:0 E
! ￼ remap (7x1) -> 15 - 0:23:0 E
! ...

! platform_info ROM:
!
! ...
! <cpus>
!   <cpu xpos="0" ypos="0" cpu_type="P" .../>
!   ...
!   <cpu xpos="5" ypos="0" cpu_type="E" .../>
!   ...
! <cpus>
! ...


Build system and tools
######################

Building and packaging CMake-based shared libraries (via Goa)
=============================================================

The [https://github.com/nfeske/goa - Goa] tool it streamlines the work of
cross-developing, testing, and publishing Genode application software
using commodity build tools like CMake. The tool is particularly suited for
porting existing 3rd-party software to Sculpt OS.

Until recently, Goa was solely focused on applications whereas the porting of
3rd-party libraries required the use of the traditional approach of hand
crafting build rules for Genode's build system. This limitation of Goa got
lifted now.

In the new version, a Goa project can host an _api_ file indicating that
the project is a library project. The file contains the list of headers that
comprise the library's public interface. The build artifact of a library
is declared in the _artifacts_ file and is expected to have the form
_<library-name>.lib.so_. The ABI symbols of such a library must be listed
in the file _symbols/<library-name>_. With these bits of information supplied
to Goa, the tool is able build and publish both the library and the API as
depot archives - ready to use by Genode applications linking to the library.
The way how all those little pieces work together is best illustrated by the
accompanied
[https://github.com/nfeske/goa/tree/master/examples/cmake_library - example].
For further details, please consult Goa's builtin documentation via 'goa help'
(overview of Goa's sub commands and files) and 'goa help api' (specifics of
the _api_ declaration file).

When porting a library to Genode, one manual step remains, which is the
declaration of the ABI symbols exported by the library. The new sub command
'goa extract-abi-symbols' eases this manual step. It automatically generates a
template for the _symbols/<library-name>_ file from the library's built shared
object. Note, however, that the generated symbols file is expected to be
manually reviewed and tidied up, e.g., by removing library-internal symbols.

_Thanks to Pirmin Duss for having contributed the welcome new feature, which_
_makes Goa much more versatile!_


New tool for querying metadata of ports
=======================================

The integration of third-party software into Genode is implemented via
_ports_ that specify how to retrieve, verify, and patch the source code in
preparation for use with our build system. Ports are managed by tools
residing in the _tool/ports_ directory. For example,
_tool/ports/prepare_port_ is used to execute all required preparation steps.

Currently, the base Genode sources support 90 ports (you may try
_tool/ports/list_ yourself) and, thus, it's not trivial to keep track of all
the ports in the repo directories. Therefore, we introduce the
_tool/ports/metadata_ tool to extract information about license, upstream
version, and source URLs of individual ports. The tool can be used like
follows.

!./tool/ports/metadata virtualbox6
!
!PORT:     virtualbox6
!LICENSE:  GPLv2
!VERSION:  6.1.26
!SOURCE:   http://download.virtualbox.org/virtualbox/6.1.26/VirtualBox-6.1.26.tar.bz2 (virtualbox)
!SOURCE:   http://download.virtualbox.org/virtualbox/6.1.26/VirtualBoxSDK-6.1.26-145957.zip (virtualbox_sdk)


Harmonization of the boot concepts across ARM and PC platforms
==============================================================

To make the system-update functionality covered in
Section [On-target system-update and rollback mechanism] equally usable across
PC and ARM platforms, the conventions of booting the platforms had to be
unified.

Traditionally, a bootable disk image for the PC contains a _boot/_ directory.
E.g., when using NOVA it contains the GRUB boot-loader config + the
hypervisor + the bender pre-boot loader + the banner image + the Genode system
image. This structure corresponds 1:1 to the _boot/_ directory as found on the
3rd partition of the Sculpt system, which is very nice. A manual system update
of Sculpt comes down to replacing these files.
However, on ARM platforms, SD-card images used to host an _uImage_ file and
a U-Boot environment configuration file the root directory. The distinction of
these differences complicate both the build-time tooling and the on-target
handling of system updates.

The current release unifies the boot convention by hosting a _boot/_ directory
on all platforms and reinforces the consistent naming of files. On ARM,
the _uImage_ and _uboot.env_ files now always reside under _boot/_.
Thanks to this uniform convention, Genode's new system update mechanism can
now equally expect that a system update corresponds to the mere replacement of
the content of the _boot/_ directory.


Minor run-tool changes
======================

The functionality of the _image/uboot_fit_ plugin has been integrated into the
regular _image/uboot_ plugin as both plugins were quite similar.
FIT images can now be produced by adding the run option '--image-uboot-fit'.

