

              ===============================================
              Release notes for the Genode OS Framework 23.08
              ===============================================

                               Genode Labs



; intro
; @nfeske



Multi-component debug monitor
#############################

The debugging of Genode components using the GNU debugger (GDB) was already
an anticipated feature when we introduces the first version of the GDB monitor
component in version
[https://genode.org/documentation/release-notes/11.05#GDB_monitor_experiment - 11.05]
and refined it in the subsequent releases
[https://genode.org/documentation/release-notes/12.02#GDB_monitor_refinements_and_automated_test - 12.02],
[https://genode.org/documentation/release-notes/13.11#GNU_Debugger - 13.11 (on-target GDB)], and
[https://genode.org/documentation/release-notes/16.05#Enhanced_GDB_support_on_NOVA - 16.05 (supporting NOVA)].
Despite these efforts, the feature remained rarely used in practice.
In most situations, manual instrumentation with debug messages or the use
of GDB with the Linux version of Genode remain to be the instruments of choice.
Driven by the vision of easy on-target debugging on Sculpt OS, we identified
the following limitations of the existing GDB monitor that stand in the way.

# The GDB monitor supports only one component as debugging target, which makes
  the debugging of scenarios where components closely interact difficult.

# The existing implementation re-uses the gdbserver code and thereby inherits
  many POSIX peculiarities that must be stubbed for Genode, yet make the
  overall implementation complex. Genode is not POSIX after all.

# The integration of the GDB monitor into an existing scenario is a fairly
  invasive change that requires too much work.

Given these limitations as a backdrop, two key ideas motivated a new approach
for the revision of Genode's GDB support for this release:

First, by using Genode's sandbox API as foundation for a new debug monitor,
we would become able to use the monitor as drop-in replacement for 'init',
potentially going as far as using the monitor for Sculpt's runtime subsystem.
Wouldn't that approach vastly simplify the integration issue (3)?
Second, GDB supports the debugging of multiple processes (called inferiors)
within one session, which would in principle allow us to inspect and debug
component compositions, addressing the first limitation.
And third, the casual review of the documentation of the GDB protocol left
the impression that a Genode-tailored implementation shouldn't be that
complicated.

The result of these ideas is the new *monitor* component at _os/src/monitor_
as the designated successor of the traditional gdb_monitor.
By leveraging the sandbox API,
it can be used as a drop-in replacement for the init component and monitor
multiple components. In real-world scenarios like Sculpt's runtime, we
deliberately want/need to restrict the debugging to a few selected components,
however, which calls for the support of a mix of monitored and regular
components hosted side by side. Given this requirement, the sandbox API had to
be enhanced to support the selective interception of PD and CPU sessions.

Like the original gdb_monitor, the new monitor speaks the GDB remote serial
protocol over Genode's terminal session. But the protocol implementation does
not re-use any gdbserver code, sidestepping the complexities of POSIX.
The monitor supports the essential GDB remote protocol commands for reading and
writing of memory and registers, for stopping and resuming of threads including
single-stepping, and it reports the occurrence of page faults and exceptions to
GDB. Breakpoints are managed by GDB using software breakpoint instructions.
The GDB protocol is operated in GDB's 'non-stop' mode, which means that
threads of multiple inferiors can be stopped and resumed individually or in
groups, depending on the GDB commands issued by the user.

As of now, the monitor supports NOVA on 64-bit x86 as well as Genode's custom
base-hw kernel on 64-bit ARM and x86. The 64-bit ARM support required a change
in Genode's customized GDB port to enable shared library support for this
architecture. So in order to use Genode's host GDB with the monitor on 64-bit
ARM, the Genode tool chain needs to be rebuilt with the _tool/tool_chain_
script.

There exist three run scripts illustrating the new component. The
_os/run/monitor.run_ script exercises memory inspection via the 'm' command
and memory modification via the 'M' command by letting a test program monitor
itself. The _os/run/monitor_gdb.run_ script performs automated tests of various
GDB commands and the _os/run/monitor_gdb_interactive.run_ script allows for the
interactive use of GDB to interact with monitored components.

Details about the configuration of the monitor component are given by
the README file at the _os/src/monitor/_ directory.


Streamlined application development via Goa
###########################################

; Find a better section title to distinguish from previous release?

; @jschlatow


Support for the mainline Rust toolchain
=======================================

When we reintroduced Rust on Genode in the
[https://genode.org/documentation/release-notes/23.05#Initial_Rust_support - previous]
release, our implementation
relied on a slightly adapted Rust toolchain to work around missing support for
versioned library symbols in our linker. With this release, we are now able to
use the mainline 'x86_64-unknown-freebsd' target provided by Rust project,
eliminating the need for a custom toolchain.

On top of the streamlined Rust support, we created a Goa package for a popular
Rust command-line application, which will be published along with updated
system packages in the upcoming Sculpt release.

For details on the mainline Rust toolchain support and the ported package,
take a look at the dedicated
[https://genodians.org/atopia/2023-08-24-enabling-the-upstream-rust-toolchain.txt - blog post on Genodians.org].


Base framework and OS-level infrastructure
##########################################

Internal core and base-framework modernization
==============================================

Genode's API received multiple rounds on modernization in the past years. But
some of the framework's deepest internals remained largely unchanged over that
time. Even though one can argue that mature and battle-tested code should
better not be disrupted, our programming practices are not carved in stone.
To make Genode's internal code a delight for reviewers, auditors, and future
maintainers, we revisited the following areas.

Core's page-fault resolution code got reworked for improved clarity and
safety, by introducing dedicated result types, reducing the use of basic
types, choosing expressive names, and fostering constness. Along the way, we
introduced a number of 'print' hooks that greatly ease manual instrumentation
and streamlines diagnostic messages printed by core. Those messages no longer
appear when a user-level page-fault handler is registered for the faulted-at
region map. So the monitor component produces less noise on the attempt to
dump non-existing memory.

Closely related to the page-fault handling, we tightened the distinction
between rx and rwx inside core by restricting 'Region_map::attach_executable'
to create read-only mappings, while offering the option to map the full rights
using a new 'attach_rwx' method. The 'attach_rwx' method is now used by the
dynamic linker to explicitly attach the linker area with full rwx rights. With
the old page-fault handling code, the execute flag was evaluated only for leaf
dataspaces, not for managed dataspaces while traversing region-map
hierarchies. With the new page-fault handling code, the execute bit is
downgraded to no-execute when passing a managed dataspace that is not attached
as executable.

We ultimately removed the last traces of the global 'env_deprecated()'
interface that was still relied-on within core and parts of the base library.
Nowadays, we no longer use global accessors but generally employ
dependency-injection patterns. Since the 'env_deprecated()' interface is
closely related to initialization code, the startup code of core and regular
components got largely refactored, eliminating the reliance on global side
effects. As a collateral change, the legacy 'main' support for native Genode
component as well as the now-obsolete 'Entrypoint::schedule_suspend' mechanism
got removed.


API changes
===========

Register framework update
-------------------------

The register framework has been updated to ease its use with '-Wconversion'
warnings enabled, which is the default for Genode components.
When reading from a bitfield, the new version returns the value in the
smallest possible integer type, not the register-access type. This way,
the user of the bitfield value can use appropriate types without the need for
casting. The update also replaces 'bool' access types with 'uint8_t' access
types.

Thanks to this change, the net lib - used by Genode's low-level network
routing components for parsing protocol headers via the register API - has
been made compliant to strict conversion warnings.


Hex-dump utility
----------------

To aid the monitoring, implementation, and debugging of binary protocols, a
handy hex-dump utility got added to _util/formatted_output.h_. The new
'Genode::Hex_dump' class can be used to print a hexadecimal dump of a byte
range. The data is printed in a format similar to that used by the 'xxd'
utility. In addition to the 'xxd' format, consecutive duplicate lines are
replaced with a single "*\n".


Libraries and applications
##########################

New NIC server for raw uplink connectivity
==========================================

With Genode
[https://genode.org/documentation/release-notes/21.02#Pluggable_network_device_drivers - 21.02],
we transitioned all network device drivers to act as session
clients in order to make them pluggable. We achieved this by introducing a new
_uplink_ service interface that is very similar to the NIC service but with the peer
roles switched. Up to now, the only uplink server and uplink-to-NIC adapter was
the NIC router. This is reasonable as it is the standard network multiplexer in
Genode and therefore normally sits in front of each network device driver
anyway. However, there is one major issue with this approach: It binds physical
network access to layer 3 and 4 routing respectively layer 2 multiplexing,
which, in our case, means that NIC clients can talk to the physical network
only with what is protocol-wise supported by the NIC router.

That's why Genode 23.08 introduces the new NIC-uplink adapter component. It
re-enables raw access to physical networks in Genode by forwarding packets
unmodified and unfiltered between multiple NIC sessions and one uplink session.
The new component is accompanied by a test script _nic_uplink.run_ that
demonstrates the low-level integration and a Sculpt package _pkg/pc_nic_ that can
be used for deployment in more sophisticated systems together with the PC
NIC-driver as back end.

One constellation, in which the NIC-uplink server will be especially useful for
us is the planned enablement of IPv6 on different layers of Genode's network
stack. More specifically, the tool will allow us to work at IPv6 support in
both Genode's ported TCP/IP stacks and the NIC router at the same time.


New depot-remove component
==========================

_The work described in this section was contributed by Alice Domage._
_Thanks for this welcome addition._

Genode's on-target package management allows for the installation of multiple
versions of the same package side by side, which is useful to roll
back the system to an earlier state, or to accommodate software depending on
an older library version. Software is installed into the so-called _depot_
stored on the target and populated with downloads on demand. Until now,
however, the on-target depot could only grow, not shrink. Even though this
limitation hasn't been a pressing concern for Sculpt OS on the PC, it impeded
embedded use cases.

The new depot-remove component lifts this limitation by providing an
orderly way to remove depot content and orphaned dependencies.
It operates by reading its configuration and
processes delete operations based on the provided rules.
A typical configuration looks as follows.

! <config arch="x86_64" report="yes">
!     <remove user="alice" pkg="nano3d"/>
!     <remove user="bob"   pkg="wm" version="2042-42-42"/>
!     <remove-all>
!         <keep user="alice" pkg="fonts_fs"/>
!     </remove-all>
! </config>

For more details about the configuration options, please refer to the README
file at _/gems/src/app/depot_remove/_. Furthermore, the
_gems/run/depot_remove.run_ script illustrates the component by exercising
several practical use cases.


DDE-Linux changes
=================

; @cnuke

commit caac994da848bcafe1425e0aaeca3fd677953fff
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Thu Jun 15 12:57:03 2023 +0200

    lx_kit: decouple schedule execution
    
    Prior to this commit, whenever an external event occurred, for example
    timer or interrupt, the corresponding I/O signal handler was triggered.
    This handler unblocked the task waiting for the event and initiated the
    immediate execution of all unblocked tasks. Since these tasks may hit
    serialization points, e.g. synchronously waiting for packet stream
    operations, that require handling of other I/O signals this leads to
    nested execution. This, however, is not supported and mixes application
    and I/O level signal handling.
    
    The flagging of the scheduling intent is now decoupled from its
    execution by using an application level signal handler that is run in
    the context of the components main entrypoint. The I/O signal handler
    now triggers the scheduling execution by sending a local signal to
    the EP.
    
    Since it might be necessary to execute a pending schedule from the EP
    directly the scheduler is extended with the 'execute' member function
    that performs the check that the scheduler is called from within the
    EP and triggers the execution afterwards.
    
    Issue #4927.

commit 1cac1340301e722025c29e888b0e417c06dc725c
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Tue Jun 20 16:17:19 2023 +0200

    lx_kit: support multiple pending IRQs
    
    Decoupling the scheduler execution can lead to missed interrupts
    because the current implementation only handles one pending
    interrupt and requires immediate processing.
    
    This commit introduces a helper object that is used to capture
    any occuring interrupts that are then handled consecutively.
    
    Issue #4927.

commit e18c02991e5239f19ad92e7787d96a109888e062
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Thu Jul 6 13:02:04 2023 +0200

    lx_kit: use central signal handler for scheduling
    
    This commit extends the Lx_kit initialization function by passing in
    a signal handler that is used to perform the normally occurring
    scheduler execution and is a follow-up change for the decoupling
    scheduler execution commit.
    
    Instead of burying the signal handler in the 'Lx_kit::Scheduler'
    object it is provided by the main object where the driver is free
    to perform any additional step before or after executing the scheduler.
    
    Issue #4927
    Fixes #4952


Tresor block encryptor
======================

Following the introduction of the tresor library in the
[https://genode.org/documentation/release-notes/23.05#Revision_of_Genode_s_custom_block-encryption_infrastructure - previous]
release,
we further polished the tresor tester in order to make it run on a broad
spectrum of target platforms. For instance, the test can now be run without
entropy input (permanently warning the user about the security risk) because
some of our test hardware lacks support for it. Besides that, we mainly worked
at the resource consumption of the test - made it more adaptable or reduced it
through improvements. This pleased not only less powerful hardware but our test
management as well.

Furthermore, we fixed a significant former deficiency with the tresor library.
The library used to work on the raw on-disc data without decoding first. This
worked fine for some platforms but caused alignment faults on others. That
said, the tresor library now always decodes into naturally typed and aligned
C++ structs before accessing the data.


Device drivers
##############

Intel GPU
=========

The handling of GPUs is somewhat special within the driver world. A GPU is a
standalone execution unit that can be programmed much like a CPU. In the past,
there were fixed function GPUs, which have been gradually replaced by dynamically
programmable units that execute compiled machine code (think shader compilers
like GLSL or general purpose computing like CUDA or OpenCL). This leads to a
situation where a GPU driver cannot trust the client that sends its machine code
to be executed by the GPU. There exists no sufficient way of inspecting the
complied machine code for malicious behavior by the GPU driver. Therefore, the
only reasonable solution for a GPU driver is to send the code to the GPU and
hope for the best. In case the code execution is not successful, GPUs tend to
just hang and the only thing a driver can do is to make sure via an IOMMU that
the code does not access arbitrary memory and  program a watchdog timer and
reset the GPU to a graceful state in case there is no proper response. With the
current Genode release, we have implemented this behavior for GEN9 (HD graphics)
and GEN12 (Intel Iris Xe).


Intel display
=============

The ported Linux Intel display driver now supports USB Type-C connectors as
used with modern notebooks.


New PC network driver based on DDE-Linux
========================================

Since 2010, we use Ethernet drivers ported from the iPXE project in a tiny
emulation layer on Genode. While those drivers did a good job for the common
cases, they always had some rough edges that may not hurt in the original
network-booting use case but had become a nuisance in Sculpt OS and Genode
in general. Most prominently the dropped link speed with Intel E1000e cards
on cable unplug/plug and the moderate throughput on GBit links had to be
addressed.

Our new DDE Linux approach introduced this year makes the porting of drivers
from the Linux kernel much easier and less labour intensive as in the past.
Also, Linux is a very tempting Ethernet driver donor because of the variety
of supported devices and the well known excellent performance (especially on
Intel devices). Moreover, the Intel E1000e driver addresses all issues we
had with the iPXE implementation and promises a smooth interplay with Intel
AMT/ME. Note, Intel AMT Serial-over-LAN is still an important debug console
while deploying Genode on Intel-based notebooks.

Hence, the current release brings the new _pc_nic_drv_ for Intel
e1000/e1000e, Realtek 8169, and AMD PCnet32 (Qemu) devices on PC and is
fully integrated into Sculpt OS. Performance-wise the driver easily
saturates 1 GBit links in our throughput tests.


USB host controller
===================

The USB host controller driver ports for Raspberry Pi 1 and i.MX 6 Quad got
updated to Linux kernel version 6.1.37 resp. 6.1.20. Both driver ports share the
renewed device-driver environment approach for Linux introduced in release
[https://genode.org/documentation/release-notes/21.08#Linux-device-driver_environment_re-imagined - 21.08].

Besides the update of the last remaining outdated USB host controller drivers, we
have reworked the common C/C++ Linux-to-Genode USB back end used by all USB
host controller driver incarnations. The internal changes were necessary to
address issues regarding races during USB session close attempts, resets
of USB endpoints, and potential stalls during synchronous USB RPC calls.


PC audio refinements
====================

; @cnuke

commit ff0ba89e917d5adf3aa072f3d3ebca80da966780
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Fri Apr 28 11:21:56 2023 +0200

    dde_bsd: update mixer state report on HP sense
    
    Issue #4946.

commit 317c5429d21e78dc9cf8bb5a8b78a2357b943b64
Author: Josef Söntgen <jws@sysret.de>
Date:   Thu Jun 22 20:42:41 2023 +0000

    dde_bsd: decrease overall memory consumption
    
    The initial memory backend implementation was brought over from DDE
    Linux and was geared towards use-cases where a high-performing
    allocator is useful. In case of the audio driver this is overkill
    and since no other driver that could benefit from such an
    implementation was ported in the meantime rather use a simpler
    implementation that keeps the overhead down.
    
    Fixes #4946.

commit 93d6d71a1de0bf56e866524780053dcb28aecb5f
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Tue Jul 11 11:30:42 2023 +0200

    dde_bsd: add patch to limit internal buffer size
    
    Decreasing the internal buffer size will implicitly limit the number
    of blocks provisioned for recording and brings them in line with
    the number of blocks used for playback (2).
    
    Note that this patch also sets an upper-bound on the number of
    samples in 'Audio_*::PERIOD'.


Wifi
====

; @cnuke

commit fc24ffcdb823c47b240385bed0ec0c96e3f1f177
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Thu Jul 6 16:25:41 2023 +0200

    wifi: use mac address reporter
    
    Remove the handcrafted MAC address reporter in favour the Genode
    C API utility (cf. #4918).
    
    Issue #4927
    Issue #4918

commit dd1b8a106fd9ef5388da8d03af15a3bcfa4ba0b2
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Fri Jul 7 11:46:39 2023 +0200

    drivers/wifi: perform multi-staged construction
    
    Since the wireless LAN driver is actually a 'Libc::Component' due to
    its incorporation of the 'wpa_spplicant' application, we have to
    intercept its construction because we have to initialize the Lx_kit
    environment before any static ctors are executed. Most Linux initcalls
    are implemented as ctors that will be otherwise implicitly executed
    before the controll is given to us in 'Libc::Component::construct'.
    
    Issue #4927.


PinePhone support for buttons and screensaver
=============================================

To equip the mobile version of Sculpt OS on the PinePhone with a proper
screensaver, we added drivers for detecting user interactions with the
PinePhone's physical buttons, namely the volume buttons and the power button.

The volume buttons are connected via cascaded resistors to a single ADC of the
A64 SoC. The corresponding driver has been added to the genode-allwinner
repository at _src/drivers/button/pinephone/_ and is accompanied by the
_button_pinephone.run_ script. It reports KEY_VOLUMEUP and KEY_VOLUMEDOWN
input events to an event session.

Sensing the power button has been a slightly more delicate issue because the
power button is connected to the power-management IC (PMIC), which shall only
be accessed via the system-control processor (SCP). To detect state changes,
the PMIC's IRQ (routed through the R_INTC to the GIC) is now handled by the
power driver. This has the added benefit that also other interesting PMIC
events (like connecting AC) get immediately reported.

With the button drivers in place, we finally equipped Sculpt OS with a
screensaver as a crucial battery-conserving feature. The screensaver
kicks in after the user remained inactive in the administrative user interface
for some time. It also can be manually activated by pressing the power button.
While the screen is blanked, a press of the power button enables the display
again.

Under the hood, Sculpt completely removes the drivers for the display and the
touchscreen while the screen is blanked, which considerably reduces the power
draw. The system also switches the CPU to economic mode while the screen is
blanked. Here are some illustrative data points:

!    Max brightness in performance mode: 2.8 W
!    Max brightness in economic mode:    2.6 W
!    Low brightness in economic mode:    1.7 W
!    Screensaver:                        1.1 W

You can find the screensaver feature integrated in the latest mobile Sculpt OS
images published by _nfeske_.


Platforms
#########

NXP i.MX SoC family
===================

Certain parts of i.MX specific code, like the base support for the hw kernel,
and the GPIO driver for i.MX got moved from Genode's main repository to the
corresponding genode-imx repository.

Sculpt OS image creation for MNT Reform2
----------------------------------------

With this release, we introduce mainline support for Sculpt OS on the MNT
Reform2. To build a Sculpt OS image for this board you can use the common
_gems/run/sculpt_image.run_ script, like the following:

! make run/sculpt_image KERNEL=hw BOARD=mnt_reform2 DEPOT=omit

To be effective, you need to extend your RUN_OPT variable accordingly:

! RUN_OPT += --include image/imx8mq_mmc


seL4 microkernel
================

With the update of the seL4 kernel in the
[https://genode.org/documentation/release-notes/23.05#Updated_seL4_microkernel - previous]
release we now added several
improvements, which reduce the boot-up time of Genode's 'core'
roottask on seL4 by converting untyped memory to I/O memory on demand.


Build system and tools
######################

Depot autopilot on-target test orchestrator
===========================================

As the rough plan to support automated testing in Goa is shaping up, it makes
sense to share one convention about expressing the success criteria for a
package under test between the depot autopilot and Goa. This prospect motivated
us to review the convention that was used with the depot autopilot up until
now. The old syntax looked as follows:

! <runtime ...>
!   <events>
!     <timeout meaning="failed" sec="20"/>
!     <log meaning="succeeded">
!       [init -> rom_logger] ROM 'generated':*
!       [init -> dynamic_rom] xray: change (finished)
!     </log>
!     <log meaning="succeeded">child exited</log>
!     <log meaning="failed">Error: </log>
!   </events>
!   ...
! </runtime>

We applied the following simplifications to this syntax:
* Dropped the intermediate '<events>' tag,
* Replaced '<log meaning="succeeded">' by '<succeed>',
* Replaced '<log meaning="failed">' by '<fail>',
* Replaced '<timeout meaning="failed" sec="20"/>' by an 'after_seconds'
  attribute of the '<succeed>' or '<fail>' tags.

So, the above example becomes the following:
! <runtime ...>
!   <fail after_seconds="20"/>
!   <succeed>
!     [init -> rom_logger] ROM 'generated':*
!     [init -> dynamic_rom] xray: change (finished)
!   </succeed>
!   <succeed>child exited</succeed>
!   <fail>Error: </fail>
!   ...
! </runtime>

For now, the depot autopilot maintains backwards-compatibility to allow Genode
users to adapt to the change progressively. The old scheme is used whenever
the package runtime contains an '<event>' tag. Note that backwards
compatibility will be removed after a short transition period.
All test packages of the official Genode repositories have been updated
to the new convention.

Furthermore, we took the opportunity to also add a new feature. The optional
'log_prefix' attribute in the '<succeed>' and '<fail>' tags is a simple but handy
white-list filter when it comes to typical Genode logs. When matching the test
log against the pattern given in the affected '<succeed>' or '<fail>' tag, the
depot autopilot considers only those log lines that start with the given
prefix. This is an easy way to watch only specific Genode components and solve
problems with the log order of simultaneously running components.

Last but not least, the transition prompted us to fix a minor issue with the
depot autopilot log-processing. Color sequences will now be forwarded correctly
from the test runtime to the log output of the depot autopilot, making the
analysis of test batteries a more pleasant experience.


Updated run-tool defaults for x86_64
====================================

With the update of the seL4 kernel and the update of the toolchain to GNU GCC
12 in the previous release, certain x86 assembly instructions like POPCNT are generated,
which are not supported by the Qemu CPU models we used.
Previously, the used CPU model was either the default model, or
'-cpu core2duo' for NOVA, or '-cpu phenom' for SVM virtualization.
The current release changes the default model to '-cpu Nehalem-v2', and
selects '-cpu EPYC' for SVM virtualization.

Note that the _build.conf_ file in the x86 build directory must be
re-generated by you, which otherwise may contain an older Qemu "-cpu " model,
which can collide with the new default Qemu CPU settings.
