

              ===============================================
              Release notes for the Genode OS Framework 23.08
              ===============================================

                               Genode Labs



; intro
; @nfeske



Multi-component debug monitor
#############################

The existing GDB monitor has a number of limitations that we need to overcome
to make on-target debugging a regular feature of Genode and Sculpt OS.

The most visible problems are:

* The GDB monitor supports only one component as debugging target, which makes
  the debugging of scenarios where components closely interact difficult.

* The existing implementation re-uses the gdbserver code and thereby inherits
  many POSIX peculiarities that must be stubbed for Genode, yet make the
  overall implementation complex.

Given these limitations, two key ideas motivated a new approach for the
revision of Genode's GDB support for this release:

First, by using Genode's sandbox API as foundation for a new debug monitor,
we would become able to use the monitor as drop-in replacement for 'init',
potentially going as far as using the monitor for Sculpt's runtime subsystem.

And second, GDB supports the debugging of multiple processes (called inferiors)
within one session, which would in principle allow us to inspect and debug
component compositions.

The result of these ideas is the new 'monitor' component at 'os/src/monitor'
as the designated successor of the 'gdb_monitor'. By leveraging the sandbox API
it can be used as a drop-in replacement for the 'init' component and monitor
multiple components. In real-world scenarios like Sculpt's runtime, we
deliberately want/need to restrict the debugging to a few selected components,
however, which calls for the support of a mix of monitored and regular
components hosted side by side. Given this requirement, the sandbox API had to
be enhanced to support the selective interception of PD and CPU sessions.

Like the 'gdb_monitor', the new monitor speaks the GDB remote serial protocol
over Genode's terminal session. But the protocol implementation does not re-use
any gdbserver code, sidestepping the complexities of POSIX.

The monitor supports the essential GDB remote protocol commands for reading and
writing of memory and registers, for stopping and resuming of threads including
single-stepping, and it reports the occurrence of page faults and exceptions to
GDB. Breakpoints are managed by GDB using software breakpoint instructions.

The monitor operates in GDB's 'non-stop' mode, which means that threads of
multiple inferiors can be stopped and resumed individually or in groups,
depending on the GDB commands issued by the user.

As a secondary functionality, the monitor wipes all RAM dataspaces allocated
by the monitored components when the RAM is freed. This is useful as a possible
defense against cold-boot attacks.

Supported debugging target platforms as of now are NOVA/x86_64, hw/x86_64 and
hw/arm_64.

For the hw platforms, we extended the low-level debugging support in the hw
kernel as needed and the hw/arm_64 support also required a change in Genode's
customized GDB port to enable shared library support for this architecture.
So, in order to use Genode's host GDB with the monitor on hw/arm_64, the Genode
tool chain needs to be rebuilt with the 'tool/tool_chain' script. Rebuilding
GDB also fixes a potential failed assertion in GDB if at least two threads are
initially stopped when GDB connects to the monitor.

There exist three run scripts illustrating the new component. The
'os/run/monitor.run' script exercises memory inspection via the 'm' command
and memory modification via the 'M' command by letting a test program monitor
itself. The 'os/run/monitor_gdb.run' script performs automated tests of various
GDB commands and the 'os/run/monitor_gdb_interactive.run' script allows for the
interactive use of GDB to interact with monitored components.

There's also a 'README' file in the 'os/src/monitor' directory with more
details regarding the configuration of the monitor component.


Streamlined application development via Goa
###########################################

; Find a better section title to distinguish from previous release?

; @jschlatow


Support for the mainline Rust toolchain
=======================================

When we reintroduced Rust on Genode in the last release, our implementation
relied on a slightly adapted Rust toolchain to work around missing support for
versioned library symbols in our linker. With this release, we are now able to
use the mainline 'x86_64-unknown-freebsd' target provided by Rust project,
eliminating the need for a custom toolchain.

On top of the streamlined Rust support, we created a Goa package for a popular
Rust command line application, which will be published along with updated
system packages in the upcoming Sculpt release.

For details on the mainline Rust toolchain support and the ported package,
take a look at the 
[https://genodians.org/atopia/2023-08-24-enabling-the-upstream-rust-toolchain.txt - update blog post on Genodians.org].


Base framework and OS-level infrastructure
##########################################

Internal core and base-framework modernization
==============================================

Genode's API received multiple rounds on modernization in the past years. But
some of the framework's deepest internals remained largely unchanged over that
time. Even though one can argue that mature and battle-tested code should
better not be disrupted, our programming practices are not carved in stone.
To make Genode's internal code a delight for reviewers, auditors, and future
maintainers, we revisited the following areas.

Core's page-fault resolution code got reworked for improved clarity and
safety, by introducing dedicated result types, reducing the use of basic
types, choosing expressive names, and fostering constness. Along the way, we
introduces a number of 'print' hooks that greatly ease manual instrumentation
and streamlines the error messages printed by core. Those messages no longer
appear when a user-level page-fault handler is registered for the faulted-at
region map. So the monitor component produces less noise on the attempt to
dump non-existing memory.

Closely related to the page-fault handling, we tightened the distinction
between rx and rwx inside core by restricting 'Region_map::attach_executable'
to create read-only mappings, while offering the option to map the full rights
using a new 'attach_rwx' method. The 'attach_rwx' method is now used by the
dynamic linker to explicitly attach the linker area with full rwx rights. With
the old page-fault handling code, the execute flag was evaluated only for leaf
dataspaces, not for managed dataspaces while traversing region-map
hierarchies. With the new page-fault handling code, the execute bit is
downgraded to no-execute when passing a managed dataspace that is not attached
as executable.

We ultimately removed the last traces of the global 'env_deprecated()'
interface that was still relied-on within core and parts of the base library.
Nowadays, we no longer use global accessors but generally employ
dependency-injection patterns. Since the 'env_deprecated()' interface is
closely related to initialization code, the startup code of core and regular
components got largely refactored, eliminating the reliance on global side
effects. As a collateral change, the legacy 'main' support for native Genode
component as well as the now-obsolete 'Entrypoint::schedule_suspend' mechanism
got removed.


API changes
===========

Register framework update
-------------------------

The register framework has been updated to ease its use with '-Wconversion'
warnings enabled, which is the default for Genode components.
When reading from a bitfield, the new version returns the value in the
smallest possible integer type, not the register-access type. This way,
the user of the bitfield value can appropriate types without the need for
casting. The update also replaces 'bool' access types with 'uint8_t' access
types.

Thanks to this change, the net lib - used by Genode's low-level network
routing components for parsing protocol headers via the register API - has
been made compliant to strict conversion warnings.


Hex-dump utility
----------------

To aid the monitoring, implementation, and debugging of binary protocols, a
handy hex-dump utility got added to _util/formatted_output.h_. The new
'Genode::Hex_dump' class can be used to print a hexadecimal dump of a byte
range. The data is printed in a format similar to that used by the 'xxd'
utility. In addition to the 'xxd' format, consecutive duplicate lines are
replaced with a single "*\n".


Libraries and applications
##########################

New NIC server for raw uplink connectivity
==========================================

With Genode 21.02, we transitioned all network device drivers to act as session
clients in order to make them pluggable. We achieved this by introducing a new
service named Uplink that is very similar to the Nic service but with the peer
roles switched. Up to now, the only Uplink server and Uplink-to-Nic adapter was
the NIC router. This is reasonable as it is the standard network multiplexer in
Genode and therefore normally sits in front of each network device driver
anyway. However, there is one major issue with this approach: It binds physical
network access to layer 3 and 4 routing respectively layer 2 multiplexing,
which, in our case, means that Nic clients can talk to the physical network
only with what is protocol-wise supported by the NIC router.

That's why Genode 23.08 introduces the new Nic-Uplink adapter component. It
re-enables raw access to physical networks in Genode by forwarding packets
unmodified and unfiltered between multiple Nic sessions and one Uplink session.
The new component is accompanied by a test script nic_uplink.run that
demonstrates the low-level integration and a Sculpt package pkg/pc_nic that can
be used for deployment in more sophisticated systems together with the PC
NIC-driver as back end.

One constellation in which the Nic-Uplink server will be especially useful for
us is the planned enablement of IPv6 on different layers of Genodes network
stack. More specifically, the tool will allow us to work at IPv6 support in
both Genodes ported TCP/IP stacks and the NIC router at the same time.


New depot-remove component
==========================

_The work described in this section was contributed by Alice Domage._
_Thanks for this welcome addition._

Genode's on-target package management allows for the installation of multiple
versions of the same package side by side, which is useful to roll
back the system to an earlier state, or to accommodate software depending on
an older library version. Software is installed into the so-called _depot_
stored on the target and populated with downloads on demand. Until now,
however, the on-target depot could only grow, not shrink. Even though this
limitation hasn't been a pressing concern for Sculpt OS on the PC, it impeded
embedded use cases.

The new depot-remove component lifts this limitation by providing an
orderly way to remove depot content and orphaned dependencies.
It operates by reading its configuration and
processes delete operations based on the provided rules.
A typical configuration looks as follows.

! <config arch="x86_64" report="yes">
!     <remove user="alice" pkg="nano3d"/>
!     <remove user="bob"   pkg="wm" version="2042-42-42"/>
!     <remove-all>
!         <keep user="alice" pkg="fonts_fs"/>
!     </remove-all>
! </config>

For more details about the configuration options, please refer to the README
file at _/gems/src/app/depot_remove/_. Furthermore, the
_gems/run/depot_remove.run_ script illustrates the component by exercising
several practical use cases.


DDE-Linux changes
=================

With this release we changed how external events are treated within the
Linux emulation environment.

Whenever an external event occurred, for example timer or interrupt, the
corresponding I/O signal handler was triggered. This handler unblocked the
task waiting for the event and also initiated the immediate execution of all
unblocked tasks. This, however, could lead to nested execution because these
tasks might hit serialization points, e.g. synchronously waiting for packet
stream operations, that under the hood also require handling of other I/O
signals. Such an execution model is not supported and confusing as it mixes
application and I/O level signal handling.

So the flagging of the scheduling intent is now decoupled from its execution by
using an application level signal handler that is run in the context of the
components main entrypoint. The I/O signal handler now triggers the scheduling
execution by sending a local signal to the EP and only flags the occurrence
of the external event by unblocking the corresponding task.
In this context we reworked the interrupt handling itself. Previously all
interrupts were immediately processed in the I/O signal handler and only the
currently pending one was handled. Due to the decoupling change the occurrence
of interrupts becomes merely flagging a state and requires to record all
interrupts and dispatch them consecutively in one go.

To facilitate this convention the Lx_kit initialization function got extended
and it is now necessary to pass in a signal handler that is used to perform the
normally occurring scheduler execution. As this signal handler is part of
the main object of the DDE-Linux based component it is the natural place to
perform any additional steps that required by the component before or after
executing the scheduler.

As it sometimes is necessary to execute a pending schedule from the EP directly,
in case the scheduler is called from within an RPC function, the scheduler is
extended with the 'execute' member function that performs the check that the
scheduler is called from within the EP and triggers the execution afterwards.


Tresor block encryptor
======================

We further polished the Tresor Tester in order to make it run on a broad
spectrum of target platforms. For instance, the test can now be run without
entropy input (permanently warning the user about the security risk) because
some of our test hardware lacks support for it. Besides that, we mainly worked
at the resource consumption of the test - made it more adaptable or reduced it
through improvements. This pleased not only less powerful hardware but our test
management as well.

Furthermore, we fixed a significant former deficiency with the Tresor library.
The library used to work on the raw on-disc data without decoding first. This
worked fine for some platforms but caused alignment faults on others. That
said, the Tresor library now always decodes into naturally typed and aligned
C++ structs before accessing the data. The speed-up of accessing decoded data
seems to compensate for the decoding effort because we did not observe a
significant performance regression.

Device drivers
##############

Intel GPU
=========

@ssumpf

commit e3c2fdf414135aa9e8f84b7767ca0c3d7a0c7098
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Mon May 22 21:57:22 2023 +0200

    gpu/intel: enable GPU reset for GEN(8)/9/12
    
    * add semaphore command to ring in order to be able to stop ring
      execution before reset (Wa KabyLake)
    * implement reset sequence as done by the Linux driver
    * reset ring and cancel job of vgpu causing hang
    * lower watchdog timeout 1000ms -> 200ms
    * improve scheduling of vgpus so progress after reset is made
    * improve the generation chaos a little
    * tested on Skylake, Kaby Lake, Tiger Lake
    
    issue #4916


Intel display
=============

The ported Linux Intel display driver now supports USB Type-C connectors as
used with modern notebooks.

New PC network driver based on DDE-Linux
========================================

Since 2010, we use Ethernet drivers ported from the iPXE project in a tiny
emulation layer on Genode. While those drivers did a good job for the common
cases, they always had some rough edges that may not hurt in the original
network-booting use case but had become a nuisance in Sculpt OS and Genode
in general. Most prominently the dropped link speed with Intel E1000e cards
on cable unplug/plug and the moderate throughput on GBit links had to be
addressed.

Our new DDE Linux approach introduced this year makes the porting of drivers
from the Linux kernel much easier and less labor intensive as in the past.
Also, Linux is a very tempting Ethernet driver donor because of the variety
of supported devices and the well known excellent performance (especially on
Intel devices). Moreover, the Intel E1000e driver addresses all issues we
had with the iPXE implementation and promises a smooth interplay with Intel
AMT/ME. Note, Intel AMT Serial-over-LAN is still an important debug console
while deploying Genode on Intel-based notebooks.

Hence, the current release brings the new _pc_nic_drv_ for Intel
e1000/e1000e, Realtek 8169, and AMD PCnet32 (Qemu) devices on PC and is
fully integrated into Sculpt OS. Performance-wise the driver easily
saturates 1 GBit links in our throughput tests.


USB host controller
===================

The USB host controller driver ports for Raspberry Pi 1 and i.MX 6 Quad got
updated to Linux kernel version 6.1.37 resp. 6.1.20. Both driver ports share the
renewed device driver environment approach for Linux introduced in release 21.08.

Beside the update of the last remaining outdated USB host controller drivers, we
have reworked the common C/C++ Linux to Genode USB backend used by all USB
host controller driver incarnations. The internal changes were necessary to
target issues regarding races during USB session close attempts, resets
of USB endpoints, and potential stalls during synchronous USB RPC calls.


PC audio refinements
====================

In this release we simplified the memory allocator in the OpenBSD-based
audio driver component and thereby decreased its memory usage.

The memory subsystem implementation was initially brought over from DDE
Linux and is geared towards use-cases where a high-performing allocator
is desired. For the audio driver with its clear memory usage pattern
such an allocator is not necessary and since no other driver that could
benefit from it was ported in the meantime we opted for replacing the
implementation with a simpler on that keeps the overhead down.

We also adapted the mixer state report mechanism to always generate a
new report on head-phone jack sense events.

Furthermore we decreased the internal buffer size to implicitly limit
the number of blocks provisioned for recording that brings them in line
with the number of blocks used for playback (2).


Wifi
====

With the [DDE-Linux changes] in place we had to adapt the initialization
procedure in the wireless LAN driver since it behaves differently to all
other DDE-Linux-based drivers components.

The driver is actually a 'Libc::Component' due to its incorporation of
the 'wpa_spplicant' application and the driver itself is confined to its
own shared-object to better separate the Linux code.

Since we implement the Linux initcalls as static constructors, we have
to initialize the Lx_kit before those are executed. This is normally
not a problem because they are executed manually from within the drivers
main object on construction. However, in a 'Libc::Component' this happens
before our main object is constructed. In the past we used a VFS plugin to
perform the initialization - as the VFS is also constructed beforehand -
but this is no longer possible as the drivers main signal handler that now
dispatch the Lx_kit event signals is not available at this point.

We decided therefore to perform a multi-staged boot-up process where
the component is now implemented as regular 'Genode::Component' that
triggers the 'Libc::Component' construction manually after performing
the Lx_kit initialization.

This change enabled us to remove the VFS 'wifi' plugin that no longer
has to be specified in the VFS configuration.

Furthermore we removed the handcrafted MAC address reporter in
favor of the Genode C API utility that was recently made available.


PinePhone support for buttons and screensaver
=============================================

To equip the mobile version of Sculpt OS on the PinePhone with a proper
screensaver, we added drivers for detecting user interactions with the
PinePhone's physical buttons, namely the volume buttons and the power button.

The volume buttons are connected via cascaded resistors to a single ADC of the
A64 SoC. The corresponding driver has been added to the genode-allwinner
repository at _src/drivers/button/pinephone/_ and is accompanied by the
_button_pinephone.run_ script.

Sensing the power button has been a slightly more delicate issue because the
power button is connected to the power-management IC (PMIC), which shall only
be accessed via the system-control processor (SCP). To detect state changes,
the PMIC's IRQ (routed through the R_INTC to the GIC) is now handled by the
power driver. This has the added benefit that also other interesting PMIC
events (like connecting AC) get immediately reported.

With the button drivers in place, we finally equipped Sculpt OS with a
screensaver as a crucial battery-conserving feature. The screensaver
kicks in after the user remained inactive in the administrative user interface
for some time. It also can be manually activated by pressing the power button.
While the screen is blanked, a press of the power button enables the display
again.

Under the hood, Sculpt completely removes the drivers for the display and the
touchscreen while the screen is blanked, which considerably reduces the power
draw. The system also switches the CPU to economic mode while the screen is
blanked. Here are some illustrative data points:

!    Max brightness in performance mode: 2.8 W
!    Max brightness in economic mode:    2.6 W
!    Low brightness in economic mode:    1.7 W
!    Screensaver:                        1.1 W

You can find the screensaver feature integrated in the latest Sculpt OS
image published by _nfeske_.


Platforms
#########

NXP i.MX SoC family
===================

Certain parts of i.MX specific code, like the base-support for the hw-kernel,
and the GPIO driver for i.MX got moved from Genode's main repository to the
corresponding genode-imx repository.

Sculpt OS image creation for MNT Reform2
----------------------------------------

With this release we introduce mainline support for Sculpt OS on the MNT
Reform2. To build a Sculpt OS image for this board you can use the common
sculpt_image.run script, like the following:

! make run/sculpt_image KERNEL=hw BOARD=mnt_reform2 DEPOT=omit

To be effective you need to extend your RUN_OPT variable accordingly:

! RUN_OPT += --include image/imx8mq_mmc

seL4 microkernel
================

With the update of the seL4 kernel in the previous release we now added several
improvements which shorten the boot-up-time of Genode's 'core'
roottask on seL4 by converting untyped memory to I/O memory on demand.

Build system and tools
######################

Depot autopilot on-target test orchestrator
===========================================

As the rough plan to support automated testing in Goa is shaping up, it makes
sense to share one convention about expressing the success criteria for a
package under test between the Depot Autopilot and Goa. This merge motivated
us to review the convention that was used with the Depot Autopilot up until
now. The old syntax looked as follows:
```
<runtime ...>
  <events>
    <timeout meaning="failed" sec="20"/>
    <log meaning="succeeded">
      [init -> rom_logger] ROM 'generated':*
      [init -> dynamic_rom] xray: change (finished)
    </log>
    <log meaning="succeeded">child exited</log>
    <log meaning="failed">Error: </log>
  </events>
  ...
</runtime>
```

We found that we wanted to apply various simplifications to this syntax:
* Drop the intermediate <events> tag.
* Replace <log meaning="succeeded"> by <succeed>.
* Replace <log meaning="failed"> by <fail>.
* Replace <timeout meaning="failed" sec="20"/> by an after_seconds
  attribute of the <success> or <fail> tags.

So, the above example would become the following:
```
<runtime ...>
  <fail after_seconds="20"/>
  <succeed>
    [init -> rom_logger] ROM 'generated':*
    [init -> dynamic_rom] xray: change (finished)
  </succeed>
  <succeed>child exited</succeed>
  <fail>Error: </fail>
  ...
</runtime>
```

Genode 23.08 adds support for this new scheme to the Depot Autopilot but keeps
backwards-compatibility for now in order to allow Genode users to adapt to the
change progressively. The Depot Autopilot always looks out for an <event> tag:
If the tag is present in a package runtime, the old scheme is being used.
Otherwise, the new one. Note that backwards-compatibility is planned to be
removed after a short transition period.

All test packages of the official Genode repositories have already been updated
to the new convention. From this experience, we can tell that automation via a
combination of xslt script and sed commands can be worth the effort if you're
maintaining a considerable number of test packages.

Furthermore, we took the opportunity to also add a new feature. The optional
'log_prefix' attribute in the <succeed> and <fail> tags is a simple but handy
white-list filter when it comes to typical Genode logs. When matching the test
log against the pattern given in the affected <succeed> or <fail> tag, the
Depot Autopilot will consider only those log lines that start with the given
prefix. This is an easy way to watch only specific Genode components and solve
problems with the log order of simultaneously running components.

Last but not least, the transition prompted us to fix a minor issue with the
Depot Autopilot log-processing. Color sequences will now be forwarded correctly
from the test runtime to the log output of the Depot Autopilot, making the
analysis of test batteries a more pleasant experience.

Updated run-tool defaults for x86_64
====================================

With the update of the seL4 kernel and the update of the toolchain to GNU GCC
12 in the previous release, x86 assembly instructions are generated,
like POPCNT, which are not supported anymore by the Qemu CPU models we used.
Previously, depending on the used kernel, either

* the default CPU model or
* -cpu core2duo for Genode@NOVA or
* -cpu phenom for SVM virtualization

was used. Because of that we changed with this release the used Qemu CPU

* by default to '-cpu Nehalem-v2'
* and to '-cpu EPYC' for SVM virtualization

With this change the build.conf file in the x86 build directory must be
re-generated by you, which otherwise may contain an older Qemu "-cpu " model,
which can collide with the new default Qemu CPU settings.
