

              ===============================================
              Release notes for the Genode OS Framework 19.11
              ===============================================

                               Genode Labs



; intro
; @nfeske
;Motivated by theme of "bridging worlds" as stated on our
;[https://genode.org/about/road-map - road map] for this year,


Preliminary block-device encryptor
##################################

; @cnuke, @m-stein


Virtualization of 64-bit ARM platforms
######################################

Genode has a long history regarding support of all kind of virtualization
techniques. Mainly, because an evolving operating system needs interim solutions
to provide non-trivial, existent software stacks. Recently in release 19.05 the
introduction of a Kernel-agnostic interface to control Virtual-Machines (VM)
ushered in a new level for the construction resp. porting of
Virtual-Machine-Monitors (VMM).
By introducing a new ARMv8 compliant VMM developed from scratch, we continue
this line of work.

The new VMM continues the Proof-of-Concept (PoC) implementation for ARMv7 introduced
in Genode release 15.02. In contrast to the former PoC implementation it aims to
be complete to a greater extent. Currently, it comprises device models for:

* RAM
* System Bus
* CPU
* Generic Interrupt Controller v2 and v3
* Generic Timer
* PL011 UART (limited)
* Pass-through devices

The VMM is ready to load diverse 64-bit Linux kernels including
Device-Tree-Binary (DTB) and Initramfs. Currently, the implementation uses a
fixed memory layout for the guest-physical memory view, which needs to be
reflected by the DTB used for the guest OS. An example device tree source file
can be found in 'repos/os/src/server/vmm/spec/arm_v8/virt.dts'. The whole VMM
implementation can be found in the same directory.

Although, support for many-core VMs is already constructed internally, it is not
ready to work free of complaints. Further outstanding features that are already
in development are Virtio device model support for networking and console.

The first and by now only backend we tied to the ARMv8 broadened Kernel-agnostic
VM-session interface is Genode's own base-hw kernel.

To give the new VMM a try, you can execute the 'repos/os/run/vmm_arm.run' on top
of the i.MX8 Evaluation Kit board.

The VMM hardly depends on the availability of the virtualization hardware
support (EL2). This hardware support comprises extensions for the ARMv8-A CPU,
ARM's Generic Timer, and ARM's GIC. Therefore, the Raspberry Pi 3
board cannot be used as basis, because it does not include a GIC, but an own
interrupt-controller without hardware-assisted virtualization of interrupts.

Within the scope of this work, we consolidated the generic VM session interface
slightly. The RPC call to create a new virtual-CPU now returns an identifier for
identification.


New tooling for bridging existing build systems with Genode
###########################################################

; @nfeske


Base framework and OS-level infrastructure
##########################################

File-system session
===================

The file-system session interface received a much anticipated update.

Writing modification times
--------------------------

The new operation WRITE_TIMESTAMP allows a client to update the modification
time of a file-system node. The time is defined by the client to keep
file-system servers free from time-related concerns. The VFS server implements
the operation by forwarding it to the VFS plugin interface. At present, this
new interface is implemented by the rump VFS plugin to store modification
times on ext file systems.


Enhanced file-status info
-------------------------

The status of a file-system node as returned by the 'File_system::Status'
operation has been revisited. First, we replaced the fairly opaque "mode" bits
- which was an ad-hoc attempt to stay compatible with Unix - with the explicit
notion of 'readable', 'writeable', and 'executable' attributes. We completely
dropped the notion of users and groups. Second, we added the distinction
between *continuous* and *transactional* files to allow for the robust
implementation of continuous write operations across component boundaries. A
continuous file can be written to via a sequence of arbitrarily sized chunks
of data. For such files, a client can split a large write operation into any
number of smaller operations in accordance to the size of I/O buffers. In
contrast, a write to a transactional file is regarded as a distinct operation.
The canonical example of a transactional file is a socket-control pseudo file.


Virtual file-system infrastructure
==================================

First fragments of a front-end API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The VFS is mostly used indirectly via the C runtime. However, it is also
useful for a few components that use the Genode API directly without any
libc. To accommodate such users of the VFS, we introduced the front-end
API at _os/vfs.h_ that covers a variety of current use cases. Currently, those
use cases revolve around the watching, reading, and parsing of files and
file-system structures - as performed by Sculpt's deployment mechanism.
Writing to files is not covered.


Improved file-watching support
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All pseudo files that use the VFS-internal 'Readonly_value_file_system'
utility have become able to deliver watch notifications. This change enables
VFS clients to respond to VFS-plugin events (think of terminal resize)
dynamically.

Speaking of the *terminal VFS plugin*, the current release enhances the plugin
in several respects. First, it now delivers status information such as the
terminal size via pseudo files. Second, we equipped the VFS terminal file
system with the ability to detect user interrupts in the incoming data stream,
and propagate this information via the new pseudo file '.terminal/interrupts'.
Each time, the user presses control-c in the terminal, the value stored in
this pseudo file is increased. Thereby, a VFS client can watch this file to
get notified about the occurrences of user interrupts.


VFS plugin for emulating POSIX pipes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We added a new VFS plugin for emulating POSIX pipes. The new plugin creates
pipes between pairs of VFS handles. It replaces the deprecated libc_pipe
plugin. In contrast to the libc_pipe plugin, which was limited to pipes within
one component, the new VFS plugin can also be used to establish pipes between
different components by using the plugin at a shared VFS server.


C runtime with improved POSIX compatibility
===========================================

Within Genode, we used to think of POSIX as a legacy that is best avoided.
In fact, the foundational components of the framework do not depend on a
C runtime at all. However, higher up the software stack - at the latest when
3rd-party libraries enter the picture - a working C runtime is unavoidable. In
this statement, the term "working" is rather muddy though. Since we have never
fully embraced POSIX, we were content with cutting corners here and there. For
example, given Genode's architecture, supporting 'fork' and 'execve' seemed
totally out of question because those mechanism would go against the grain of
Genode.

However, our growing aspiration to bridge the worlds between existing
applications and Genode made us re-evaluate our stance towards POSIX.
All technical criticism aside, POSIX is immensely useful because it is
an universally accepted stable interface. To dissolve friction between
Genode and popular application software, we have to satisfy the application's
expectations. This ignited a series of developments, in particular
the added support for 'fork' and 'execve' of all things in
[https://genode.org/documentation/release-notes/19.08#Consolidation_of_the_C_runtime_and_Noux - Genode 19.08],
which was nothing short of surprising, even to us.
The current release continues this line of development and brings the
following improvements.


Execve
------

The libc's 'execve' implementation got enhanced to evaluate the
path of the executable binary according to the information found on the VFS,
in particular by traversing directories and following symbolic
links. This enables the libc to execute files stored at sub
directories of the file system.

Furthermore, 'execve' received handling for *executing shell scripts* by
parsing shebang marker at the beginning of the executable file. This
way, the 'execve' / 'fork' mechanism of the libc reaches parity with the
feature set of the Noux runtime that we traditionally used to execute
Unix software on top of Genode.


Modification-time handling
--------------------------

By default, the libc uses the just added facility for updating the timestamp
of file-system nodes when closing a written-to file, which clears the path
towards using tools like 'make' that rely on file-modifications times.

The libc's mechanism can be explicitly disabled by specifying
! <libc update_mtime="no"...>
This is useful for applications that have no access to a time source.


Emulation of 'ioctl' operations via pseudo files
------------------------------------------------

With the current release, we introduce a new scheme of handling ioctl
operations, which maps 'ioctl' calls to pseudo-file accesses, similar to how
the libc already maps socket calls to socket-fs operations.

A device file can be accompanied with a (hidden) directory that is named after
the device file and hosts pseudo files for triggering the various device
operations. For example, for accessing a terminal, the directory structure
looks like this:

! /dev/terminal
! /dev/.terminal/info
! /dev/.terminal/rows
! /dev/.terminal/columns

The 'info' file contains device information in XML format. The type of the XML
node corresponds to the device type. Whenever the libc receives a 'TIOCGWINSZ'
ioctl for _/dev/terminal_, it reads the content of _/dev/.terminal/info_ to
obtain the terminal-size information. In this case, the 'info' file looks as
follows:

! <terminal rows="25" columns="80/>

Following this scheme, VFS plugins can support ioctl operations by providing
an ioctl directory in addition to the actual device file.


Emulation of POSIX signals
--------------------------

Even though there is no notion of POSIX signals at the Genode level, we
can reasonably emulate certain POSIX signals at the libc level. The current
release introduces the first bunch of such emulated signals:

:SIGWINCH: If 'stdout' is connected to a terminal, the libc watches the
  terminal's ioctl pseudo file _.terminal/info_. Whenever the terminal
  size changes, the POSIX signal SIGWINCH is delivered to the application.
  With this improvement, Vim becomes able to dynamically adjust itself
  to changed window dimensions when started as a native Genode component
  (w/o the Noux runtime environment).

:SIGINT: If 'stdin' is connected to a terminal, the libc watches the
  terminal's pseudo file _.terminal/interrupts_. Since, the terminal VFS
  plugin modifies the file for each occurred user interrupt (control-c),
  the libc is able to reflect such an event as SIGINT signal to the
  application.

:Process-local signal delivery: The libc's implementation of 'kill' got
  enhanced with the ability to submit signals to the local process.


Support for arbitrarily large write operations
----------------------------------------------

The number of bytes written by a single 'write' call used to be constrained by
the file's underlying I/O buffer size. Even though our libc correctly returned
this information to the application, we found that real-world applications
rarely check the return value of 'write' because partial writes do not occur
on popular POSIX systems. Thanks to the added distinction between continuous
and transactional files as described in Section [File-system session] we could
now improve the libc's write operation to iterate on partial writes to
continuous files until the original write count is reached. The split of large
write operations into small partial writes as dictated by the VFS
infrastructure becomes invisible to the libc-using application.


Input-event handling
====================

In Genode 19.08, we undertook a comprehensive rework of our
keyboard-event handling in the light of localization and also promised
to tie up remaining loose ends soon.

First, we again dived into our character generators for a thorough
check of our stack of keyboards and fixed remaining inconsistencies in
French and German layouts. En passant, we also increased the default
RAM quotas for input_filter to 1280K in our recipes to cope with the
increased layout-configuration sizes in corner cases.

Next (and more importantly), we subdued the monsters lurking in our
Qt5 keyboard backend and enabled transparent support for system-wide
keyboard layout configuration for Qt5 components. One important change
during this work was to move the handling of Control key sequences
into the clients. For example, the graphical terminal and Qt5
interpret key events in combination with the CTRL modifier based on
characters and, thus, support CTRL-A with AZERTY and QWERTY layouts
correctly. As a result we removed all CTRL modifier mod2 configurations
from our character-generator configurations.

Finally we'd like to point out one important change of our rework that
repeatedly led to surprises: For keys without character mappings the
reworked character-generator mechanism emits invalid codepoints in
contrast to codepoints with value 0. For that reason, components
interpreting character events should check 'Codepoint::valid()' to
prevent processing of invalid characters (and not the frequent pattern
of 'codepoint.value != 0').


NIC router
==========

; @m-stein

commit 27c2a66bbde5a3a65349b8a5d472bc61179e79a5
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Tue Oct 15 18:56:37 2019 +0200

    nic_router: report link state
    
    This adds two new boolean attributes to the <report> tag of the NIC router
    configuration 'link_state' and 'link_state_triggers'. The former decides
    whether to report the link state of each NIC interface (downlink, uplinks) at
    the NIC router. The other decides whether to trigger reporting each time the
    link state of an interface changes.
    
    Fixes #3527


Device drivers
==============

Platform driver on x86
~~~~~~~~~~~~~~~~~~~~~~

; @chelmuth

commit 6df8b446165d8ea01defe29886c28a994f5e2b65
Author: Christian Helmuth <christian.helmuth@genode-labs.com>
Date:   Mon Sep 23 15:29:05 2019 +0200

    platform/x86: support 64-bit base address registers
    
    The API still exports 32-bit address and size values only, which works
    as the actual MMIO resources are allocated in platform_drv internally.
    
    Fixes #3494


Wireless driver
~~~~~~~~~~~~~~~

; @cnuke

commit c5706e8f4a9f4e5cd3960eac6f659895147fc9b3
Author: Josef Söntgen <josef.soentgen@genode-labs.com>
Date:   Mon Sep 23 17:24:34 2019 +0200

    wifi_drv: enable loading of 5000 series FW
    
    Fixes #3502.

commit 25aa25c6a07770f95d33bb125ec37dd16b8e1d18
Author: Josef Söntgen <jws@sysret.de>
Date:   Wed Nov 20 10:50:56 2019 +0100

    wifi_drv: enable loading of 9000 series FW
    
    Tested with a 'Intel(R) Wireless-AC 9462' device.
    
    Fixes #3556.


Libraries and applications
##########################

VirtualBox improvements
=======================

The GUI handling of our Virtualbox port got improved to react on
window size changes more instantly. The effect is that an interactive
adjustment of the window size, e.g. on Sculpt, becomes quickly visible to the
user. Still, the VM may take some time to adjust to the resolution change,
which depends on having installed guest addition drivers and the time the
guest driver decides to react on the resolution change finally.

Updated 3rd-party software
==========================

With the addition of the 64-bit ARM architecture (aarch64) with the Genode 19.05
release it became necessary to update libraries the Genode tool chain (gcc)
depends on in order to support aarch64 properly. This concerns the GNU multi
precision arithmetic library (gmp) which has been updated from version 4.3.2 to
6.1.2, as well as the libraries that depend on it: Multi precision floating
point (mpfr) and multi precision complex arithmetic (mpc). All those old
versions did not offer support for the aarch64 architecture which is a
requirement to make Genode self hosting. Targets for building binutils and gcc
within Genode for aarch64 are in place, GNU make is in place, and even code
coverage (gcov) has been added. This work puts aarch64 in line with other Genode
supported CPU architectures and emphasizes our interest in the ARM 64-bit
architecture.

Platforms
#########

Execution on bare hardware (base-hw)
====================================

With the last release 19.08 Genode's base-hw kernel got extended to support the
ARMv8-A architecture in principle. The first hardware supported was the
Raspberry Pi 3 as well as the i.MX8 evaluation kit (EVK). But only a single
CPU-core was useable at that time. Now, this limitation gets resolved. On both
boards all four CPU-cores are available henceforth.


Removed components
##################

The current release removes the following components:

:gems/src/app/launcher:

  The graphical launcher remained unused for a few years now. It is not
  suitable for systems as flexible as Sculpt OS.

:os/src/app/cli_monitor:

  CLI monitor was a runtime environment with a custom command-line interface
  to start and stop subsystems. It was part of the user interface of our
  first take on a Genode-based desktop OS called
  [https://genode.org/documentation/release-notes/15.11#Genode_as_desktop_OS - Turmvilla].

  Nowadays, we use standard command-line tools like Vim to edit init
  configurations dynamically, which alleviates the need for a custom CLI.
  The CLI-monitor component was too limited for use cases like Sculpt
  anyway.

  Along with the CLI monitor, we removed the ancient (and untested for long
  time) _terminal_mux.run_ script, which was the only remaining user of the CLI
  monitor.

:fatfs_fs, rump_fs, and libc_fatfs plugin:

  The stand-alone file-system servers fatfs_fs and rump_fs as well as the
  fatfs libc plugin have been superseded by the fatfs and rump VFS plugins.
  The stand-alone servers can be replaced by using the VFS server plus the
  corresponding VFS plugin as a drop-in replacement.
